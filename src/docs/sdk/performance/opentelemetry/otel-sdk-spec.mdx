To transform SDK data to Sentry, we rely on the [OpenTelemetry SpanProcessor](https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#span-processor). The SpanProcessor is a component that runs on the same thread as the application code, so it effectively runs in process alongside user code and the Sentry SDK.

### Step 1: Implement the SentrySpanProcessor on your SDK

Below we have written a custom SpanProcessor that will transform the OpenTelemetry spans to Sentry spans.

This relies on a couple key assumptions.

1. Hub/Scope propogation works properly in your platform. This means that the hub used in `onStart` is the same hub used in `onEnd` and it means that hubs fork properly in async contexts.
2. The SDK is initialized before the OpenTelemetry SDK is initialized.
3. There will only be a single transaction occuring at the same time. This is a limitation of the current SDK design.

```ts
import { SpanProcessor } from '@opentelemetry/sdk-trace-base';
import { Span as OpenTelemetrySpan } from '@opentelemetry/api';
import { Span as SentrySpan } from '@sentry/tracing';

class SentrySpanProcessor implements SpanProcessor {
  /**
   * A map that stores a spanId to a tuple of a span and it's parent span.
   * Used to decide what span gets finished.
   */
  private readonly _map: Record<SentrySpan['spanId'], [span: SentrySpan, parentSpan?: SentrySpan]>;

  constructor(options: SentrySpanProcessorOptions) {
    this._options = options;
  }

  onStart(otelSpan: OpenTelemetrySpan): void {
    const hub = Sentry.getCurrentHub();
    const scope = hub.getScope();

    if (!hub || !scope) return;

    const otelSpanId = span.spanContext().spanId;

    const parentSpan = scope.getSpan();
    if (parentSpan) {
      // If the parentSpan exists, we create a new span as a child of the parentSpan
      const childSpan = parentSpan.startChild({
        description: otelSpan.name,
        instrumentor: 'otel',
        // don't define op because we will do that on span.finish
      });

      if (childSpan) {
          // We store the otelSpan and it's parent in the map
          this._map[otelSpanId] = [childSpan, parentSpan];
          scope.setSpan(childSpan);
      }

    } else {
      // Will grab Dynamic Sampling Context and sentry-trace header if available
      const traceCtx = getTraceData(otelSpan);
      // If the parentSpan doesn't exist, we create a new transaction
      const transaction = Sentry.startTransaction({
        name: otelSpan.name,
        ...traceCtx,
        instrumentor: 'otel'
        // don't define op because we will do that on span.finish
      });

      if (transaction) {
          // We store the otelSpan and it's parent in the map
          this._map[otelSpanId] = [transaction, undefined];
          scope.setSpan(transaction);
      }
    }
  }

  onEnd(otelSpan: OpenTelemetrySpan): void {
    const hub = Sentry.getCurrentHub();
    const scope = hub.getScope();

    if (!hub || !scope) return;

    const otelSpanId = otelSpan.spanContext().spanId;
    const mapVal = this._map[otelSpanId];

    if (mapVal) {
      const [sentrySpan, parentSpan] = mapVal;

      // Update op, description, and attach otel resource attributes
      updateSpanWithOtelData(sentrySpan, otelSpan);

      // We finish the span
      sentrySpan.finish();
      // We set the parent span as the active span if parent span is defined
      if (parentSpan) {
          scope.setSpan(parentSpan);
      }
      // We remove the span from the map
      delete this._map[otelSpanId];
    }
  }
}
```

Users are required to add this `SentrySpanProcessor` to their OpenTelemetry SDK initialization logic to make this work, like so. Individual SDK implementations might be a little different.

```ts
import { NodeSDK } from "@opentelemetry/sdk-node";
import { Resource } from "@opentelemetry/resources";
import * as Sentry from "@sentry/node";
import { SentrySpanProcessor } from "@sentry/opentelemetry-node";

Sentry.init({
  /// ...
});

const sdk = new NodeSDK({
  resource: new Resource({
    "service.name": "my-service",
    "service.version": "1.0.0",
  }),
  spanProcessor: new SentrySpanProcessor(),
});
```

### Step 2: Define `getTraceData`

We want to make sure a transaction is started with information from the `sentry-trace` and `baggage` headers.

TODO

### Step 3: Define `updateSpanWithOtelData`

We want to update the Sentry Span with the OpenTelemetry data. This includes the span's operation, description, and resource attributes.

TODO

### Step 3: Add OpenTelemetry Context

All SDKs are required to add event context with the key `otel` to events generated by the SpanProcessor. This is detailed in <Link to="./#opentelemetry-context">our spec for the Context</Link>. The OpenTelemetryContext should be generated from information from the OpenTelemetry Span.

```ts
{
  contexts: {
    otel: {
      attributes: {
        "http.method": "GET",
        "http.url": "https://example.com",
        "http.status_code": 200,
      },
      service: {
        name: "my-service",
        version: "1.0.0",
      },
      otel_sdk: {
        name: "opentelemetry-node"
        version: "4.0.0",
      },
      // ...
    }
  },
}
```

### Step 4: Add instrumentor option to Sentry SDK

We want to avoid double instrumenting the same library. To do this, we want to add an option to the Sentry SDK that disables Sentry performance auto-instrumentation when OpenTelemetry is enabled. For now users will have to manually add this option to their SDK initialization code, but in the future we can do this automatically (by detecting if OpenTelemetry exists).

TODO @neel about this section and how it works

```ts
Sentry.init({
  // ...
  instrumentor: "otel",
});
```

Internally in the Sentry SDK, we can use this `instrumentor` option to disable Sentry performance auto-instrumentation.

```ts
class Hub implements HubInterface {
  // ...
  startTransaction(
    this: Hub,
    context: TransactionContext
  ): Transaction | undefined {
    // ...
    if (this._options.instrumentor === "otel") {
      return;
    }
    // ...
  }
}
```

```ts
class Transaction extends Span {
  // ...
  finish(this: Transaction, context: SpanContext): Span | undefined {
    // ...
    if (this._hub._options.instrumentor !== this._instrumentor) {
      return;
    }
    // ...
  }
}
```
