---
title: 'Making an API Public'
---

## Introduction

In this document, we explain both how you make an API public and the considerations to take into account before doing so.

## Definitions

### Managed Client

A managed client is one that Sentry controls, such as our frontend. In this type of client, we control both which endpoints are used and the attributes used by those endpoints.

### Partially Managed Client

A partially-managed client is one that we only partially control, since we do not control the version of the client that is running for our users; for example, our Sentry CLI. While we control the endpoints the CLI uses, once the CLI is installed and running in a customer's implementation, we don't control the version of the client a user runs.

### External Client

An external client is a client that Sentry does not control; for example, a script written by a customer run in their repository, or an integration written using the Integration Platform. For this type of client, we have no control over the endpoints they choose to use, nor can we require that they immediately update their endpoint.

### Private API

A private API is an undocumented API. Sentry can make breaking changes to this type of API, and no one will blink an eye.

### Public API

Our public API is documented at [https://docs.sentry.io/api/](https://docs.sentry.io/api/).

### Private Attributes in a Public Endpoint

You can have private attributes within a public endpoint.

As an example: [https://docs.sentry.io/api/teams/retrieve-a-team/](https://docs.sentry.io/api/teams/retrieve-a-team/). The response has multiple attributes:

```json
{
  "id": "2",
  "slug": "the-interstellar-jurisdiction"
  ...
}
```

Let's say we also return a `nickname` for a team. If what is returned is not documented as a response in our public documentation, that attribute is a private attribute within a public endpoint.

## API Versioning

Currently, Sentry's API is v0 and is considered to be in draft phase. While we don't expect our public endpoints to change greatly, keep in mind that our API is still under development.

## Making an endpoint public

When you make an endpoint public, you're committing to always returning at least the set of defined attributes when that endpoint is called. As a result, the attribute(s) **cannot be removed** from an endpoint after they are public. Additionally, the type of the attribute **cannot be changed** once the attribute is public. The reason the attribute and its type cannot be changed is because both external and managed clients are relying on the public attribute to be returned from that endpoint.

You **can** add attributes to a public endpoint.

## When to make an API public?

Making an API public offers considerable benefits. A public API allows our customers to incorporate Sentry into their workflows. It also gives Sentry more visibility in our customers' organizations ("Woah that's cool data, where'd it come from?"..."Sentry!"). Remember, however, making an API public means that once an endpoint is public, you can only add to it: You cannot make _any_ breaking changes.

As a guide, use these questions:

1. Is the feature for which you're making the public endpoint stable?
2. Will the API change substantially in the future?

If your answers are Yes and No, you're in business - make the endpoint public. Head over to the [public API checklist](/api/checklist/) and ensure that your endpoint conforms to the checklist.

## How to make an endpoint public?

We use [Open API Spec 3](https://swagger.io/docs/specification/about/) and the [drf-spectacular](https://drf-spectacular.readthedocs.io/en/latest/readme.html) library to document our APIs.

**API Documentation consists of**:

1. Public Declaration
2. Sidebar Tab
3. Method Decorator
  1. Title
  2. Path and Query Parameters
  3. Request Schema
  4. Response Schema
  5. Example Response
4. Endpoint Description

Below we'll describe how to document these for an endpoint.

### Declaring Public

Declare the endpoint public by setting the `public` attribute with the appropriate HTTP request methods.

```python
class OrganizationTeamsEndpoint(...):
  public = {"GET", "POST"}
```

### Sidebar Tab

Specify the endpoint's [sidebar tab](https://docs.sentry.io/api/) by using the 
`@extend_schema` decorator on the endpoint class. You can see the current list of tags or add tags
[here](https://github.com/getsentry/sentry/blob/master/src/sentry/apidocs/build.py). In the below
example the [endpoint](https://docs.sentry.io/api/discover/query-discover-events-in-table-format/)
is tagged in the `Discover` sidebar tab.

```python
from drf_spectacular.utils import extend_schema

@extend_schema(tags=["Discover"])
class OrganizationEventsEndpoint(...):
  public = {"GET"}
```

### Method Decorator

We utilize the drf-spectacular's [`@extend_schema`](https://drf-spectacular.readthedocs.io/en/latest/drf_spectacular.html#drf_spectacular.utils.extend_schema)
decorator to document the majority of the endpoint. The example below provides an overview of all
the necessary fields, and we provide step-by-step instructions to replicate this example.

```python
@extend_schema(
    operation_id="Create a New Team",
    parameters=[
        GlobalParams.ORG_SLUG,
        GlobalParams.name("The name for the team.", required=True),
        GlobalParams.slug(
            "Optional slug for the team. If not provided a slug is generated from the name."
        ),
    ],
    request=TeamPostSerializer,
    responses={
        201: TeamSerializer,
        400: RESPONSE_BAD_REQUEST,
        403: RESPONSE_FORBIDDEN,
        404: OpenApiResponse(description="A team with this slug already exists."),
    },
    examples=TeamExamples.CREATE_TEAM,
)
def post(self, request, organization, **kwargs):
    """
    Create a new team bound to an organization.
    """
```

#### Title

Specify an `operation_id` that will be shown as the title of the endpoint's page in the documentation.
```python
@extend_schema(
    operation_id="Create a New Team",
    ...
)
```


#### Path and Query Parameters

Specify the parameters using a list, and a serializer if needed.

- DRF serializers work very well for query parameters, try to use them where possible.

#### Request Schema

Specify the request serializer.

- Request serializers, since they use DRF serializers, can generally just be the serializer itself.
  There is plenty of customization and if needed can be overriden with `inline_serializer`. See
  [here](https://github.com/getsentry/sentry/blob/b04c1c04f1e86bc040a671ad5b545d3b70132140/src/sentry/scim/endpoints/members.py#L434-L440)
  for an example of this.

```python
...
request=TeamPostSerializer,
...
```

#### Response Schema

Specify the response serializer which is used to generate the response schema and validate the
repsonse example.

- For our response serializers, you must type the `serialize` function's return with a `TypedDict`
  and pass the serializer as a parameter in `extend_schema`. See
  [here](https://github.com/getsentry/sentry/blob/b04c1c04f1e86bc040a671ad5b545d3b70132140/src/sentry/api/serializers/models/organization_member/scim.py#L14-L30)
  for an example of this.
- If the response is a wrapper or you need more customization, you can use the
  `inline_sentry_response_serializer` function. A common for use case for this is returning a list
  of serialized items depicted below

```python
from sentry.apidocs.utils import inline_sentry_response_serializer

@extend_schema(
  responses={
    200: inline_sentry_response_serializer(
      "OrganizationList",
      # return a list of TypedDicts
      List[OrganizationSerializerResponse])
  }
)
```
- Note that you can also provide OpenAPI JSON if you are running into issues.

For error responses, use the existing `OpenApiRespone` constants defined 
[here](https://github.com/getsentry/sentry/blob/master/src/sentry/apidocs/constants.py). You can
also define your own if needed for more detailed messages. See below for an example of this.

```python
...
responses={
    201: TeamSerializer,
    400: RESPONSE_BAD_REQUEST,
    403: RESPONSE_FORBIDDEN,
    404: OpenApiResponse(description="A team with this slug already exists."),
},
...
```

#### Example Response

```python
from drf_spectacular.types import OpenApiExample

class TeamExamples:
  CREATE_TEAM = [
      OpenApiExample(
          "Create a new team", # description of example
          value={"slug": "my-team", "name": "My Team"}, # response body
          status_codes=["201"], # the status code(s) this example applies to
          response_only=True, # You MUST INCLUDE this for all examples!!!
      )
  ]
```

### Endpoint Description

The description shown on the documentation page matches the docstring of the endpoint.
```python
def post(self, request, organization, **kwargs):
    """
    Create a new team bound to an organization.
    """
```

See [here](https://github.com/getsentry/sentry/blob/master/src/sentry/api/endpoints/organization_teams.py) for an example of an endpoint documented using drf-spectacular, and the [drf-spectacular docs here](https://drf-spectacular.readthedocs.io/en/latest/) to learn more.

**Note that if the endpoint you're modifying had previous JSON documentation, you must delete the 
old documentation path in [this file](https://github.com/getsentry/sentry/blob/master/api-docs/openapi.json) 
and its corresponding JSON build in [this folder](https://github.com/getsentry/sentry/blob/master/api-docs/paths).**

**Additionally if there are multiple request types in the same endpoint using the old JSON
documentation, you must update both of them in the same PR. Updating only one request and
deleting the old documentation will cause the other unedited request to disappear from the docs.**

**Tips**:

- `make test-api-docs` builds the OpenAPI JSON and runs all API docs tests.
- To only build the docs, run `make build-api-docs`. The build will fail if there are any warnings.
- To see the diff of your newly generated docs with prod, run `make diff-api-docs`. This requires you to have built the OpenAPI JSON already.

**To see your changes in the docs locally**:

In `sentry`:

1. Run `make watch-api-docs`. This command will watch API docs files and continuously build an intermediate asset `tests/apidocs/openapi-derefed.json`.
2. Copy the full path to `{YOUR_SYSTEM_FOLDER}/tests/apidocs/openapi-derefed.json`, e.g. `/Users/yourname/code/sentry/tests/apidocs/openapi-derefed.json`.

In `sentry-docs`:

1. Run `OPENAPI_LOCAL_PATH=COPIED_FULL_PATH DISABLE_THUMBNAILS=1 yarn start` and substitute `COPIED_FULL_PATH` with the copied path to your local openapi-derefed.json

See [here](https://docs.sentry.io/contributing/environment/) for detailed doc build instructions.

When you open the pull request, please add a screenshot of the page or pages you're adding.

### Build process

The openapi-diff test will fail when CI runs on your pull request, this is expected and meant to highlight the diff. It is not required to merge.

Once you make changes to an endpoint and merge the change into Sentry, a series of GitHub Actions will be triggered to make your changes automatically go live:

1. The [`openapi` workflow in `sentry`](https://github.com/getsentry/sentry/blob/master/.github/workflows/openapi.yml) updates the schema in [sentry-api-schema](https://github.com/getsentry/sentry-api-schema) with the OpenAPI build artifact.
2. The [`cascade-to-sentry-docs` workflow in `sentry-api-schema`](https://github.com/getsentry/sentry-api-schema/blob/main/.github/workflows/cascade-to-sentry-docs.yml) reacts to the push to `main` in (1) by triggering the [`bump-api-schema-sha` workflow in `sentry-docs`](https://github.com/getsentry/sentry-docs/blob/master/.github/workflows/bump-api-schema-sha.yml).
3. The [`bump-api-schema-sha` workflow in `sentry-docs`](https://github.com/getsentry/sentry-docs/blob/master/.github/workflows/bump-api-schema-sha.yml) fetches the latest commit SHA from `sentry-api-schema` and writes it into the correct file, then makes and merges a PR in `sentry-docs`, which kicks off a deploy via Vercel to https://docs.sentry.io/api/.

### Requesting an API to be public

Want an endpoint to be public?

Look at the [issues on sentry with the `Component: API` label](https://github.com/getsentry/sentry/issues?q=is%3Aopen+is%3Aissue+label%3A%22Component%3A+API%22). If a request has already been made to make the endpoint public, give it a thumbs up. If not, create a [feature request](https://github.com/getsentry/sentry/issues/new?template=feature.yml) on Sentry and add the `Component: API` label.

The team responsible for the endpoint will review the stability of the endpoint. If the endpoint will not have breaking changes in future, they can determine whether to make it public.

### FAQs

**When should an attribute be `required`?**

An attribute is `required` if it will always be returned by the API.

**What does it mean when a response doesn't have a schema?**

Some endpoints have no response schema. This means that while the endpoint is public, the attributes within that endpoint can change at any time. This is a relic from migrating the documentation from our prior approach. Note that, going forward, we recommend new endpoints always provide response schema.

**I have a question and it has not been answered.**

No problem. Send us an [email](mailto:partners@sentry.io) so we can answer your question.

## Can customers use private endpoints?

Yes, if they wish. However, private endpoints can change at any time, without notice. As a result, the customer's code could break.
