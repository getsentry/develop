---
title: Technical Spec
sidebar_order: 2
---

Dynamic Sampling is a feature that allows Sentry to automatically adjust the amount of data retained based on the value of the data. This is technically achieved by applying a **sample rate** to every event, which is determined by a set of rules that are evaluated for each event.

A single or multiple rules combined are what we call **biases** or **sampling priorities**. For example the latest release bias can support multiple concurrent boosts of different releases, which leads to multiple rules being created.

## The Concept of Fidelity

Sentry plans declare fidelity, which translates to an overall target sample rate that should be applied across all transactions of an organization. Within this target sample rate, Dynamic Sampling can create a **bias toward more meaningful data**. This is achieved by constantly updating and communicating special rules to Relay, via a project configuration, which then applies targeted sampling to every event.

### Approximate Fidelity

It is important to note that fidelity only determines an **approximate target sample rate**, so there is flexibility in creating exact sample rates. The ingestion pipeline does not have the infrastructure to track volume so that it can create an actual weighted distribution within the target sample rate.

Instead, the Sentry backend computes set of rules whose goal is to cooperatively achieve the target sample rate. Determining when and how to set these rules is part of the Dynamic Sampling infrastructure.

<Alert title="⚠️ Note" level="info">

The effectively applied sample rate, in the end, depends on how much data matches each of the bias overrides.

</Alert>

## Biases for Sampling

The set of rules that Relay pulls from Sentry is called a **bias**. A bias is a set of one or more rules that are evaluated for each event. More specifically, when we define a bias, we want to achieve a specific objective, that can be expressed as a set of rules.

Sentry has already defined a set of biases that are available to all customers. These biases have all different goals but they can combine to express more complex semantics.

### Deprioritize Health Checks

This bias is used to deprioritize transactions that are classified as health checks. The goal is to reduce the amount of data that is retained for health checks, since they are not very useful for debugging.

In order to mark a transaction as a health check, we leverage a list of known health check endpoints. This list is maintained by Sentry and is updated regularly.

```python
HEALTH_CHECK_GLOBS = [
    "*healthcheck*",
    "*healthy*",
    "*live*",
    "*ready*",
    "*heartbeat*",
    "*/health",
    "*/healthz",
]
```

The list of health check endpoints is available [here](https://github.com/getsentry/sentry/blob/4cb0d863de1ef8e3440153cb440eaca8025dee0d/src/sentry/dynamic_sampling/rules/biases/ignore_health_checks_bias.py#L14).

### Prioritize Dev Environments

This bias is used to prioritize transactions that are coming from a development environment. The goal is to increase the amount of data that is retained for development environments, since they are more likely to be useful for debugging.

In order to mark a transaction as a development environment, we leverage a list of known development environments. This list is maintained by Sentry and is updated regularly.

```python
ENVIRONMENT_GLOBS = [
    "*debug*",
    "*dev*",
    "*local*",
    "*qa*",
    "*test*",
]
```

The list of development environments is available [here](https://github.com/getsentry/sentry/blob/4cb0d863de1ef8e3440153cb440eaca8025dee0d/src/sentry/dynamic_sampling/rules/biases/boost_environments_bias.py#L7).

### Prioritize New Releases

This bias is used to prioritize transactions that are coming from a new release. The goal is to increase the sample rate in the time window that incurs between the creation of a release and its adoption by users.

Since the adoption of a release is not constant, we created a system of _decaying_ rules which can interpolate between two sample rates in a given time window with a given function (e.g. `linear`).

The latest release bias uses a decaying rule to interpolate between a starting sample rate and an ending sample rate over a time window that is statically defined for each platform. For example Android has a bigger time window that Javascript because Android apps take more time to get adopted by users.

### Prioritize Low Volume Transactions

This bias is used to prioritize low volume transactions that can be drowned out by high volume transactions. The goal is to rebalance sample rates of the individual transactions so that low volume transactions are more likely to have representative samples.

In order to rebalance transactions the system computes the counts of the transactions for each project and runs an algorithm that given the sample rate of the organization and the counts of each transaction, computes a new sample rate for each transaction assuming an ideal distribution of the counts.

### Uniform Bias

This bias is the simplest bias that can be defined. It applies on any incoming event and has the goal of containing the sample rate defined on a per project basis.

The sample rate of the uniform bias is computed with a special algorithm that is based on the base sample rate, known as target fidelity rate. This rate is defined at the org level and it is done in the `quotas.get_blended_sample_rate` function.

The algorithm used for computing the uniform bias sample rate is used to prioritize low volume projects that can be drowned out by high volume projects. The goal is to rebalance sample rates of the individual projects so that low volume projects are more likely to contain transactions.

In order to rebalance the projects, this bias uses a similar mechanism to the low volume transactions bias. The system computes the counts of the transactions for each project and runs an algorithm that given the sample rate of the organization and the counts of each project, computes a new sample rate for each project assuming an ideal distribution of the counts.

<Alert title="⚠️ Note" level="info">

The algorithms for the low volume transactions and uniform bias are run periodically (with cron jobs) with a sliding window in order to account for changes in the incoming volume.

</Alert>
